// MIT License
//
// Copyright (c) 2024 Elliot Goodrich
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include "trimutil.h"
#ifdef _WIN32
#include <ninja/getopt.h>
#else
#include <getopt.h>
#endif

#include <cassert>
#include <fstream>
#include <iostream>
#include <optional>
#include <sstream>
#include <string>
#include <variant>

namespace {

const std::string_view g_helpText = R"HELP(Usage:
  trimja [--version] [--help] [-f <path>] [--write | -o <path>] [-r <path>]

trimja is a tool to create a smaller ninja build file containing only those
build commands that relate to a specified set of files. This is commonly used
to improve CI performance for pull requests.

trimja requires a .ninja_deps file when the input ninja build file contains
dynamic dependencies (e.g. from describing header file dependencies). A
complete version of this file is generated by ninja itself after a successful
build.

Examples:

Build only those commands that relate to fibonacci.cpp,
  $ echo "fibonacci.cpp" > changed.txt
  $ trimja --file build.ninja --restrict changed.txt --output small.ninja
  $ ninja -f small.ninja

Build only those commands that relate to files that differ from the main
branch,
  $ git diff main --name-only | trimja --write
  $ ninja

Options:
  -f FILE, --file=FILE      path to input ninja build file [default=build.ninja]
  -r FILE, --restrict=FILE  specify [default=stdin]
  -o FILE, --output=FILE    output file path [default=stdout]
  -w, --write               write to input ninja build file
  -h, --help                print help
  -v, --version             print trimja version ()HELP" TRIMJA_VERSION
                                    R"HELP()

For more information visit the homepage https://github.com/elliotgoodrich/trimja)HELP";

static const option g_longOptions[] = {
    // TODO: Remove `--expected` and replace with comparing files within CTest
    {"expected", required_argument, nullptr, 'e'},
    {"file", required_argument, nullptr, 'f'},
    {"help", no_argument, nullptr, 'h'},
    {"output", required_argument, nullptr, 'o'},
    {"restrict", required_argument, nullptr, 'r'},
    {"version", no_argument, nullptr, 'v'},
    {"write", no_argument, nullptr, 'w'},
    {},
};

template <class... Ts>
struct overloaded : Ts... {
  using Ts::operator()...;
};

}  // namespace

int main(int argc, char** argv) try {
  using namespace trimja;

  struct Stdout {};
  struct Write {};
  struct Expected {};
  std::variant<Stdout, Write, Expected, std::filesystem::path> outputFile;

  std::optional<std::filesystem::path> restrictFile;
  std::optional<std::string> expectedFile;
  std::filesystem::path ninjaFile = "build.ninja";
  for (int ch = 0; ch != -1;
       ch = getopt_long(argc, argv, "e:f:ho:r:vw", g_longOptions, nullptr)) {
    switch (ch) {
      case 0:
        break;
      case 'e':
        if (std::get_if<Stdout>(&outputFile)) {
          outputFile.emplace<Expected>();
          expectedFile = optarg;
        } else if (std::get_if<std::filesystem::path>(&outputFile)) {
          std::cerr << "Cannot specify --expected when --output was given"
                    << std::endl;
          std::quick_exit(EXIT_FAILURE);
        } else if (std::get_if<Write>(&outputFile)) {
          std::cerr << "Cannot specify --expected when --write was given"
                    << std::endl;
          std::quick_exit(EXIT_FAILURE);
        } else {
          assert(false);
          std::quick_exit(EXIT_FAILURE);
        }
        break;
      case 'f':
        ninjaFile = optarg;
        break;
      case 'h':
        std::cout << g_helpText;
        std::quick_exit(EXIT_SUCCESS);
      case 'o':
        if (std::get_if<Stdout>(&outputFile)) {
          outputFile.emplace<std::filesystem::path>(optarg);
        } else if (std::get_if<Write>(&outputFile)) {
          std::cerr << "Cannot specify --output when --write was given"
                    << std::endl;
          std::quick_exit(EXIT_FAILURE);
        } else if (std::get_if<Expected>(&outputFile)) {
          std::cerr << "Cannot specify --output when --expected was given"
                    << std::endl;
          std::quick_exit(EXIT_FAILURE);
        } else {
          assert(false);
          std::quick_exit(EXIT_FAILURE);
        }
        break;
      case 'r':
        restrictFile = optarg;
        break;
      case 'v':
        std::cout << TRIMJA_VERSION << "" << std::endl;
        std::quick_exit(EXIT_SUCCESS);
      case 'w':
        if (std::get_if<Stdout>(&outputFile)) {
          outputFile.emplace<Write>();
        } else if (std::get_if<std::filesystem::path>(&outputFile)) {
          std::cerr << "Cannot specify --write when --output was given"
                    << std::endl;
          std::quick_exit(EXIT_FAILURE);
        } else if (std::get_if<Expected>(&outputFile)) {
          std::cerr << "Cannot specify --write when --expected was given"
                    << std::endl;
          std::quick_exit(EXIT_FAILURE);
        } else {
          assert(false);
          std::quick_exit(EXIT_FAILURE);
        }
        break;
      case '?':
        std::cerr << "Unknown option" << std::endl;
        std::quick_exit(EXIT_FAILURE);
      default:
        std::cerr << "Unknown command line parsing error" << std::endl;
        std::quick_exit(EXIT_FAILURE);
    }
  }

  // Copy everything from the ninja into a stringstream in case we
  // are overwriting the file
  const std::string ninjaFileContents = [&] {
    std::stringstream ninjaCopy;
    std::ifstream ninja(ninjaFile);
    ninjaCopy << ninja.rdbuf();
    return ninjaCopy.str();
  }();

  std::ifstream changedFileStream;
  std::istream& changed =
      restrictFile.has_value()
          ? (changedFileStream.open(*restrictFile), changedFileStream)
          : std::cin;

  std::variant<std::monostate, std::ofstream, std::stringstream> outStream;
  std::ostream& output = std::visit(
      overloaded{[](Stdout) -> std::ostream& { return std::cout; },
                 [&](Write) -> std::ostream& {
                   return outStream.emplace<std::ofstream>(ninjaFile);
                 },
                 [&](Expected) -> std::ostream& {
                   return outStream.emplace<std::stringstream>();
                 },
                 [&](const std::filesystem::path& out) -> std::ostream& {
                   return outStream.emplace<std::ofstream>(ninjaFile);
                 }},
      outputFile);

  TrimUtil::trim(output, ninjaFile, ninjaFileContents, changed);
  if (!expectedFile.has_value()) {
    std::quick_exit(EXIT_SUCCESS);
  }

  const std::string_view actual = std::get<std::stringstream>(outStream).view();

  std::ifstream expected(*expectedFile);
  std::stringstream expectedBuffer;
  expectedBuffer << expected.rdbuf();
  if (actual != expectedBuffer.view()) {
    std::cout << "Output is different to expected\n"
              << "actual:\n"
              << actual << "---\n"
              << "expected:\n"
              << expectedBuffer.view() << std::endl;
    std::quick_exit(EXIT_FAILURE);
  } else {
    std::cout << "Files are equal!\n"
              << "actual:\n"
              << actual << "---\n"
              << "expected:\n"
              << expectedBuffer.view() << std::endl;
    std::quick_exit(EXIT_SUCCESS);
  }
} catch (const std::exception& e) {
  std::cout << e.what() << std::endl;
  std::quick_exit(EXIT_FAILURE);
}